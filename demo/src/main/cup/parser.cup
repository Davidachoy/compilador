package com.compiler;
import java.util.List;

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.LinkedList;

class Parser;

//Probar crear un arbol(futuro)

parser code {:
    // define the symbol table
       private SymbolTable symbolTable = new SymbolTable();

       public void report_error(String message, Object info) {
              StringBuilder m = new StringBuilder("Error de sintaxis");
              if (info instanceof java_cup.runtime.Symbol) {
              java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
              if (s.left >= 0) {
                     m.append(" en la línea "+ (s.left+1));
                     if (s.right >= 0)
                     m.append(", columna "+ (s.right+1));
              }
              m.append(": "+message);
              }
              System.err.println(m);
       }


       public void printSymbolTable() {
        symbolTable.printAllScopes();
    }

    public void report_semantic_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error semántico");

    if (info instanceof java_cup.runtime.Symbol) {
        java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
        if (s.left >= 0) {
            m.append(" en la línea "+ (s.left+1));
            if (s.right >= 0)
                m.append(", columna "+ (s.right+1));
        }
    }

    m.append(": "+message);
    System.err.println(m.toString());
    //System.exit(1);  // Terminate the program with an error status
   } 

:};



/** simbolos terminales **/

terminal             IF, ELSE, WHILE, FOR, INT, RETURN, FLOAT, BOOL, CHAR, STRING, ELIF, DO, READ, PRINT, MAIN, TRUE, BREAK, FALSE;
terminal             LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal             PLUS, MINUS, MUL, DIV, EQ, EQEQ, LESS_THAN, LESS_THAN_EQUAL, GREATER_THAN, GREATER_THAN_EQUAL, NOT_EQUAL, AND, OR;
terminal             INCREMENT, DECREMENT, POWER, MODULO, DOLAR, NOT;
terminal             IDENTIFIER, INTEGER_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STRING_LITERAL;
terminal             COMMA;


/** simbolos no terminales **/


non terminal         Program, Main, Functions, Function, Function_id, Param;
non terminal         Type, error_until_dolar ;

//Statements
non terminal List    StatementList,Parameters;
non terminal         Statement;
non terminal         Declaration;
non terminal         ReadFunction;
non terminal         PrintFunction;
non terminal         InvocationParams;
non terminal         FunctionCall;
non terminal         ControlStructure;
non terminal         Assign;
non terminal         Array_declaration;
non terminal         Array_assign;



//expr
non terminal         expr, expr_rel, expr_log, expr_bin;
non terminal         op_log, op_rel, op_bin, op_mult, op_unario;
non terminal         term, factor;
non terminal         Literals;

//extra 
non terminal         InvParam;
non terminal         Array_expr;
//Control Structure

non terminal         If_Structure, Elif_Structure, For_Structure,  Do_While_Structure;
non terminal         If_Branch, Elif_Branch, Else_Branch;
non terminal         Inc_for, Cond_for, inc_for;



precedence left PLUS, MINUS;
precedence left MUL, DIV, MODULO;
precedence right POWER;
precedence left AND, OR;
precedence left LESS_THAN, LESS_THAN_EQUAL, GREATER_THAN, GREATER_THAN_EQUAL, EQEQ, NOT_EQUAL;
precedence right INCREMENT, DECREMENT, MINUS;


// Regla inicial

start with Program;

//main-functions

Program ::=     Main
              | Main Functions
              | Functions Main 
              | Functions Main Functions;

Functions ::=   Functions Function
              | Function;

Main ::= INT MAIN LPAREN RPAREN LBRACE {: symbolTable.pushScope(); :}  StatementList RBRACE {: symbolTable.popScope(); :};        

Function ::= Function_id:id LPAREN Parameters RPAREN LBRACE {: symbolTable.pushScope(); :} StatementList RBRACE
              {: 
                     symbolTable.popScope();
                     if (symbolTable.getSymbol(id.toString()) == null) {
                            SymbolInfo info = new SymbolInfo();
                            info.setType("function");
                            symbolTable.addSymbol(((FunctionID)id).getId(),info); 
                     }else {
                    report_semantic_error("Funcion ya definida: " + id.toString(), id);
                       } :};
                    


Function_id ::= Type:t IDENTIFIER:id 
               {: RESULT = new FunctionID(t.toString(), id.toString()); :};

Parameters ::=  Param
                |Parameters COMMA Param
                |  ;                            
Param ::= Type:t IDENTIFIER:id;
//statements 

StatementList ::=      StatementList:s Statement:e    {: s.add(e); RESULT = s; :}
                     |                                {: RESULT = new LinkedList(); :};


Statement   ::= error_until_dolar
              | Declaration DOLAR
              | BREAK DOLAR
              | RETURN expr DOLAR
              | ReadFunction DOLAR
              | PrintFunction DOLAR
              | ControlStructure
              | Array_assign DOLAR
              | Array_declaration DOLAR
              | FunctionCall:id DOLAR
              {:
                     SymbolInfo info = symbolTable.getSymbol(id.toString());
                     if (info == null){
                            report_semantic_error("Funcion no definida: " + id, id);
                     }else{
                            RESULT = id;
                     }
                    

                     :};
              | Assign DOLAR;



FunctionCall ::=        IDENTIFIER:id LPAREN RPAREN {: RESULT = id;:}
                     |  IDENTIFIER:id LPAREN InvocationParams RPAREN{: RESULT = id;:};

InvocationParams ::=    InvocationParams COMMA InvParam
                     |  InvParam;


InvParam ::=     Literals
              |  IDENTIFIER;

//arrays
Array_declaration ::= Type IDENTIFIER LBRACKET expr RBRACKET;

Array_assign ::= IDENTIFIER LBRACKET expr RBRACKET EQ expr;

Array_expr ::= IDENTIFIER LBRACKET expr RBRACKET ;
// assing 

Assign ::=       IDENTIFIER:id EQ expr:e
                     {:


                 SymbolInfo info = symbolTable.getSymbol(id.toString());
                if (info == null) {
                   report_semantic_error("Identificador no definido: " + id.toString(), id);
                } else {
                     info.setValue(e);

                }
           
                     :}
              |  IDENTIFIER EQ ReadFunction
              |  IDENTIFIER EQ PrintFunction;

// Declaration 

Declaration::=   Type:t IDENTIFIER:id
                {:
                if (symbolTable.getSymbol(id.toString()) == null) {
                    SymbolInfo info = new SymbolInfo();
                    info.setType(((Type)t).getTypeName());
                    symbolTable.addSymbol(id.toString(), info);
                    RESULT = new Declaration((Type)t, id.toString());
                } else {
                    report_semantic_error("Variable ya definida: " + id.toString(), id);
                }
            :}
              |  Type:t IDENTIFIER:id EQ expr:e
              {:
                if (symbolTable.getSymbol(id.toString()) == null) {
                    SymbolInfo info = new SymbolInfo();
                    info.setType(((Type)t).getTypeName());
                    info.setValue(e);
                    symbolTable.addSymbol(id.toString(), info);
                    RESULT = new Declaration((Type)t, id.toString());
                } else {
                    report_semantic_error("Variable ya definida: " + id.toString(), id);
                }
            :}
              |  Type IDENTIFIER EQ ReadFunction
              |  Type IDENTIFIER EQ PrintFunction;

// if - elif - else - for - do-while  

ControlStructure ::=   If_Structure 
                     | For_Structure
                     | Do_While_Structure;

//if

If_Structure ::= If_Branch Elif_Structure Else_Branch;

If_Branch ::= IF LPAREN expr RPAREN LBRACE {: symbolTable.pushScope(); :}  StatementList RBRACE {: symbolTable.popScope(); :};

Elif_Structure ::=  Elif_Structure Elif_Branch
                 |  ;

Elif_Branch ::=  ELIF LPAREN expr RPAREN LBRACE {: symbolTable.pushScope(); :} StatementList RBRACE {: symbolTable.popScope(); :};

Else_Branch ::=  ELSE LBRACE {: symbolTable.pushScope(); :} StatementList RBRACE {: symbolTable.popScope(); :}
              |  ;


//for

For_Structure ::= FOR LPAREN Cond_for DOLAR expr DOLAR inc_for RPAREN LBRACE {: symbolTable.pushScope(); :}  StatementList RBRACE {: symbolTable.popScope(); :} ;

inc_for  ::=     INCREMENT IDENTIFIER
               | DECREMENT IDENTIFIER
               | Assign;

Cond_for ::=     Declaration
               | Assign;

//do-while

Do_While_Structure::= DO LBRACE {: symbolTable.pushScope(); :}  StatementList RBRACE {: symbolTable.popScope(); :} WHILE LPAREN expr RPAREN DOLAR;

// READ - PRINT

ReadFunction ::=        READ LPAREN RPAREN
                     |  READ LPAREN Literals RPAREN
                     |  READ LPAREN IDENTIFIER RPAREN  ;


PrintFunction ::=       PRINT LPAREN RPAREN
                     |  PRINT LPAREN Literals RPAREN
                     |  PRINT LPAREN IDENTIFIER RPAREN  ;

// types

Type ::= INT         {: RESULT = new Type("int"); :}
       | FLOAT       {: RESULT = new Type("float"); :}
       | CHAR        {: RESULT = new Type("char"); :}
       | BOOL        {: RESULT = new Type("bool"); :}
       | STRING      {: RESULT = new Type("string"); :}; 

//errors

error_until_dolar ::=   error DOLAR
                     {:
                            System.err.println("Error de sintaxis. Recuperación en modo pánico activada.");
                     :}
                     |  error error_until_dolar;

//expressions

expr ::= expr_rel:exr {:RESULT = exr;:};

expr_rel ::=     expr_log:exl {:RESULT = exl;:}
              |  expr_rel op_log expr_rel
              |  expr_log op_rel expr_log
              |  expr_rel op_rel expr_rel;

expr_log ::=     expr_bin:exb {:RESULT = exb;:}
              |  expr_log op_log expr_log
              |  NOT expr_log;

expr_bin ::=     term:t {:RESULT = t;:}
              |  expr_bin op_bin term;

term ::=  factor:f {:RESULT = f;:}
       |  term op_mult factor;

factor ::=       INTEGER_LITERAL:intL      {:RESULT = intL;:}
              |  FLOAT_LITERAL:floatL      {:RESULT = floatL;:}
              |  TRUE:trueL                {:RESULT = trueL;:}
              |  FALSE:falseL              {:RESULT = falseL;:}
              |  CHAR_LITERAL:charL        {:RESULT = charL;:}
              |  STRING_LITERAL:stringL    {:RESULT = stringL;:}
              |  IDENTIFIER:id             
                     {:
                     SymbolInfo info = symbolTable.getSymbol(id.toString());
                     if (info == null){
                            report_semantic_error("Identificador no definido: " + id, id);
                     }else{
                            RESULT = id;
                     }
                    

                     :}
              |  op_unario factor
              |  LPAREN expr:e RPAREN     {:RESULT = e;:}
              |  Array_expr
              |  FunctionCall:id
              {:
                     SymbolInfo info = symbolTable.getSymbol(id.toString());
                     if (info == null){
                            report_semantic_error("Funcion no definida: " + id, id);
                     }else{
                            RESULT = id;
                     }
                    

                     :};

// operators

op_log ::=       AND        {:RESULT = "^";:} 
              |  OR         {:RESULT = "#";:} ;

op_rel ::=       EQEQ                     {:RESULT = "==";:}
              |  LESS_THAN                {:RESULT = "<";:}
              |  LESS_THAN_EQUAL          {:RESULT = "<=";:}
              |  GREATER_THAN             {:RESULT = ">";:}
              |  GREATER_THAN_EQUAL       {:RESULT = ">=";:}
              |  NOT_EQUAL                {:RESULT = "!=";:};

op_bin ::=       PLUS       {:RESULT = "+";:}
              |  MINUS      {:RESULT = "-";:}
              |  MUL        {:RESULT = "*";:}
              |  DIV        {:RESULT = "/";:}
              |  MODULO     {:RESULT = "~";:}
              |  POWER      {:RESULT = "**";:};

op_mult ::=      MUL        {:RESULT = "*";:}
              |  MODULO     {:RESULT = "~";:}
              |  DIV        {:RESULT = "/";:};

op_unario ::=    INCREMENT  {:RESULT = "++";:}
              |  DECREMENT  {:RESULT = "--";:}
              |  MINUS      {:RESULT = "-";:};

//literals

Literals::=      INTEGER_LITERAL
              |  FLOAT_LITERAL
              |  TRUE
              |  FALSE
              |  CHAR_LITERAL
              |  STRING_LITERAL;




