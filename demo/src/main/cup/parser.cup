package com.compiler;
import java.util.List;

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.LinkedList;

class Parser;

//Probar crear un arbol(futuro)

parser code {:
    // define the symbol table
       private SymbolTable symbolTable = new SymbolTable();

       public void report_error(String message, Object info) {
              StringBuilder m = new StringBuilder("Error de sintaxis");
              if (info instanceof java_cup.runtime.Symbol) {
              java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
              if (s.left >= 0) {
                     m.append(" en la línea "+ (s.left+1));
                     if (s.right >= 0)
                     m.append(", columna "+ (s.right+1));
              }
              m.append(": "+message);
              }
              System.err.println(m);
       }
       public void printSymbolTable() {
        symbolTable.printSymbolTable();
    }

    public void report_semantic_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error semántico");

    if (info instanceof java_cup.runtime.Symbol) {
        java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
        if (s.left >= 0) {
            m.append(" en la línea "+ (s.left+1));
            if (s.right >= 0)
                m.append(", columna "+ (s.right+1));
        }
    }

    m.append(": "+message);
    System.err.println(m.toString());
    //System.exit(1);  // Terminate the program with an error status
   } 

:};



/** simbolos terminales **/

terminal             IF, ELSE, WHILE, FOR, INT, RETURN, FLOAT, BOOL, CHAR, STRING, ELIF, DO, READ, PRINT, MAIN, TRUE, BREAK, FALSE;
terminal             LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal             PLUS, MINUS, MUL, DIV, EQ, EQEQ, LESS_THAN, LESS_THAN_EQUAL, GREATER_THAN, GREATER_THAN_EQUAL, NOT_EQUAL, AND, OR;
terminal             INCREMENT, DECREMENT, POWER, MODULO, DOLAR, NOT;
terminal             IDENTIFIER, INTEGER_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STRING_LITERAL;
terminal             COMMA;


/** simbolos no terminales **/


non terminal         Program, Main, Functions, Function, Function_id, Parameters, Param;
non terminal         Type, error_until_dolar ;

//Statements
non terminal List    StatementList;
non terminal         Statement;
non terminal         Declaration;
non terminal         ReadFunction;
non terminal         PrintFunction;
non terminal         InvocationParams;
non terminal         FunctionCall;
non terminal         ControlStructure;
non terminal         Assign;
non terminal         Array_declaration;
non terminal         Array_assign;



//expr
non terminal         expr, expr_rel, expr_log, expr_bin;
non terminal         op_log, op_rel, op_bin, op_mult, op_unario;
non terminal         term, factor;
non terminal         Literals;

//extra 
non terminal         InvParam;
non terminal         Array_expr;
//Control Structure

non terminal         If_Structure, Elif_Structure, For_Structure,  Do_While_Structure;
non terminal         If_Branch, Elif_Branch, Else_Branch;
non terminal         Inc_for, Cond_for, inc_for;



precedence left PLUS, MINUS;
precedence left MUL, DIV, MODULO;
precedence right POWER;
precedence left AND, OR;
precedence left LESS_THAN, LESS_THAN_EQUAL, GREATER_THAN, GREATER_THAN_EQUAL, EQEQ, NOT_EQUAL;
precedence right INCREMENT, DECREMENT, MINUS;


// Regla inicial

start with Program;

//main-functions

Program ::=     Main
              | Main Functions
              | Functions Main 
              | Functions Main Functions;

Functions ::=   Functions Function
              | Function;

Main ::= INT MAIN LPAREN RPAREN LBRACE StatementList RBRACE;        

Function ::= Function_id LPAREN Parameters RPAREN LBRACE StatementList RBRACE;

Function_id ::= Type IDENTIFIER;

Parameters ::=   Param 
                | Parameters COMMA Param
                |;

Param ::= Type IDENTIFIER; 

//statements 

StatementList ::=      StatementList:s Statement:e    {: s.add(e); RESULT = s; :}
                     |                                {: RESULT = new LinkedList(); :};


Statement   ::= error_until_dolar
              | Declaration DOLAR
              | BREAK DOLAR
              | RETURN expr DOLAR
              | ReadFunction DOLAR
              | PrintFunction DOLAR
              | ControlStructure
              | Array_assign DOLAR
              | Array_declaration DOLAR
              | FunctionCall
              | Assign DOLAR;



FunctionCall ::=        IDENTIFIER LPAREN RPAREN
                     |  IDENTIFIER LPAREN InvocationParams RPAREN;

InvocationParams ::=    InvocationParams COMMA InvParam
                     |  InvParam;


InvParam ::=     Literals
              |  IDENTIFIER;

//arrays
Array_declaration ::= Type IDENTIFIER LBRACKET expr RBRACKET;

Array_assign ::= IDENTIFIER LBRACKET expr RBRACKET EQ expr;

Array_expr ::= IDENTIFIER LBRACKET expr RBRACKET ;
// assing 

Assign ::=      IDENTIFIER EQ expr
              |  IDENTIFIER EQ ReadFunction
              |  IDENTIFIER EQ PrintFunction;

// Declaration 

Declaration::=   Type:t IDENTIFIER:id
                {:
                if (symbolTable.getSymbol(id.toString()) == null) {
                    SymbolInfo info = new SymbolInfo();
                    info.setType(((Type)t).getTypeName());
                    symbolTable.addSymbol(id.toString(), info);
                    RESULT = new Declaration((Type)t, id.toString());
                } else {
                    report_semantic_error("Variable ya definida: " + id.toString(), id);
                }
            :}
              |  Type:t IDENTIFIER:id EQ expr:e
              {:
                if (symbolTable.getSymbol(id.toString()) == null) {
                    SymbolInfo info = new SymbolInfo();
                    info.setType(((Type)t).getTypeName());
                    info.setValue(e)
                    symbolTable.addSymbol(id.toString(), info);
                    RESULT = new Declaration((Type)t, id.toString(), e.toString());
                } else {
                    report_semantic_error("Variable ya definida: " + id.toString(), id);
                }
            :}
              |  Type IDENTIFIER EQ ReadFunction
              |  Type IDENTIFIER EQ PrintFunction;

// if - elif - else - for - do-while  

ControlStructure ::=   If_Structure 
                     | For_Structure
                     | Do_While_Structure;

//if

If_Structure ::= If_Branch Elif_Structure Else_Branch;

If_Branch ::= IF LPAREN expr RPAREN LBRACE StatementList RBRACE ;

Elif_Structure ::=  Elif_Structure Elif_Branch
                 |  ;

Elif_Branch ::=  ELIF LPAREN expr RPAREN LBRACE StatementList RBRACE;

Else_Branch ::=  ELSE LBRACE StatementList RBRACE
              |  ;


//for

For_Structure ::= FOR LPAREN Cond_for DOLAR expr DOLAR inc_for RPAREN LBRACE StatementList RBRACE;

inc_for  ::=     INCREMENT IDENTIFIER
               | DECREMENT IDENTIFIER
               | Assign;

Cond_for ::=     Declaration
               | Assign;

//do-while

Do_While_Structure::= DO LBRACE StatementList RBRACE WHILE LPAREN expr RPAREN DOLAR;

// READ - PRINT

ReadFunction ::=        READ LPAREN RPAREN
                     |  READ LPAREN Literals RPAREN
                     |  READ LPAREN IDENTIFIER RPAREN  ;


PrintFunction ::=       PRINT LPAREN RPAREN
                     |  PRINT LPAREN Literals RPAREN
                     |  PRINT LPAREN IDENTIFIER RPAREN  ;

// types

Type ::= INT         {: RESULT = new Type("int"); :}
       | FLOAT       {: RESULT = new Type("float"); :}
       | CHAR        {: RESULT = new Type("char"); :}
       | BOOL        {: RESULT = new Type("bool"); :}
       | STRING      {: RESULT = new Type("string"); :}; 
//errors
error_until_dolar ::=   error DOLAR
                     {:
                            System.err.println("Error de sintaxis. Recuperación en modo pánico activada.");
                     :}
                     |  error error_until_dolar;

//expressions

expr ::= expr_rel;

expr_rel ::=     expr_log
              |  expr_rel op_log expr_rel
              |  expr_log op_rel expr_log
              |  expr_rel op_rel expr_rel;

expr_log ::=     expr_bin
              |  expr_log op_log expr_log
              |  NOT expr_log;

expr_bin ::=     term
              |  expr_bin op_bin term;

term ::=  factor
       |  term op_mult factor;

factor ::=       INTEGER_LITERAL
              |  FLOAT_LITERAL
              |  TRUE
              |  FALSE
              |  CHAR_LITERAL
              |  STRING_LITERAL
              |  IDENTIFIER
              |  op_unario factor
              |  LPAREN expr RPAREN
              |  Array_expr
              |  FunctionCall;

// operators

op_log ::=       AND
              |  OR;

op_rel ::=       EQEQ
              |  LESS_THAN
              |  LESS_THAN_EQUAL
              |  GREATER_THAN
              |  GREATER_THAN_EQUAL
              |  NOT_EQUAL;

op_bin ::=       PLUS
              |  MINUS
              |  MUL
              |  DIV
              |  MODULO
              |  POWER;

op_mult ::=      MUL
              |  MODULO
              |  DIV;

op_unario ::=    INCREMENT
              |  DECREMENT
              |  MINUS;

//literals

Literals::=      INTEGER_LITERAL
              |  FLOAT_LITERAL
              |  TRUE
              |  FALSE
              |  CHAR_LITERAL
              |  STRING_LITERAL;




